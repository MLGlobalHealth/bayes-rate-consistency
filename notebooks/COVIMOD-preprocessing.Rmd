---
title: "COVIMOD Preprocessing"
author: "Shozen Dan"
date: '2022-07-16'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
```{r message=FALSE}
# Load libraries
library(data.table)
library(stringr)
library(ggplot2)
library(dplyr)
library(pammtools)

# Load helpers
source("../R/load_covimod_data.R")
source("../R/fill_missing_child_ages.R")
source("../R/age_gender_grid.R")

SEED <- 0721
```

## Load data

- The code loads data from a directory using load_covimod_data.
- The loaded data is then split into three different data tables: dt_participants, dt_non_household, and dt_household.
- The code limits the data in all three tables to the first 5 waves using the subset function [wave <= 5].
```{r}
covimod <- load_covimod_data("~/bayes-rate-consistency")
dt_participants <- covimod$part
dt_non_household <- covimod$nhh
dt_household <- covimod$hh

# Limit to first 5 waves
dt_participants <- dt_participants[wave <= 5]
dt_non_household <- dt_non_household[wave <= 5]
dt_household <- dt_household[wave <= 5]
```

## Participant data

- The code removes participants with missing age-strata or gender information from dt_participants using the is.na function.
- The code creates a new column rep in dt_participants that counts the number of times a participant repeatedly participated in the survey using the seq_len function.
- The rep column is adjusted to a maximum value of 4 using the ifelse function.
- The fill_missing_child_ages function is applied to dt_participants to impute missing children age using a uniform distribution with a specified seed.
- A new index u is created in dt_participants that is a combined index of wave and rep using the fcase function.
- Rows in dt_participants with a u value of 11 are removed using the subset function.
- The code creates three variables u.unique, u.full, and u.missing to identify missing u values and prints u.missing.
```{r}
# Remove participants with missing age-strata or gender information
dt_participants <- dt_participants[!is.na(gender) & !is.na(age_strata)]

# The number of times a participant repeatedly participated in the survey
dt_participants[, rep := seq_len(.N), by = .(new_id)]
dt_participants[, rep := rep - 1]
dt_participants[, rep := ifelse(rep > 4, 4, rep)]

# Impute children age by sampling from uniform distribution
dt_participants <- fill_missing_child_ages(dt_participants, seed = SEED)

# Create a new index U which is a combined index of wave and rep
dt_participants[, u := fcase(wave == 1, 1, 
                     wave == 2, 2 + rep,
                     wave >= 3, 1/2*(wave - 1)*(wave) + rep + 1)]

dt_participants <- dt_participants[u != 11]

# Missing Us
u.unique <- sort(unique(dt_participants$u))
u.full <- seq(1, max(u.unique))
u.missing <- u.full[!(u.full %in% u.unique)]

print(u.missing)
# Note: We would probably need to pool waves when we do full analysis as there is too much
```

## Non-household contacts
### Ambiguous contacts
```{r}
# Identify contacts with missing age and gender
dt.amb <- dt_non_household[is.na(alter_age_strata) | is.na(alter_gender)]

# Append participant info
dt.amb <- merge(dt.amb[,.(new_id, wave)], dt_participants, by=c("new_id", "wave"), all.x = TRUE)

# Treat all as missing (some have either gender or age-strata info)
dt.amb <- dt.amb[, list(y_amb = .N), by=c("new_id", "u")]

hist(dt.amb$y_amb) # Quick visualization

# Truncate at 30 (to remove extreme cases where people reported 30+ contacts)
dt.amb <- merge(dt.amb, dt_participants, by=c("new_id", "u"), all.x = TRUE)

# Remove ambiguous contacts from original nhh data
dt_non_household <- dt_non_household[!(is.na(alter_age_strata) | is.na(alter_gender))]
```

### Group contacts
```{r}
SDcols_Q75 <- c("Q75_u18_work", "Q75_u18_school", "Q75_u18_else", 
                "Q75_1864_work", "Q75_1864_school", "Q75_1864_else",
                "Q75_o64_work", "Q75_o64_school", "Q75_o64_else")

dt_participants[, y_grp := rowSums(.SD, na.rm = T), .SDcols = SDcols_Q75]
dt_participants[y_grp > 60, y_grp := 60]

dt.grp <- dt_participants[, .(y = sum(y_grp)), by=.(wave, imp_age, gender)]
setnames(dt.grp, "imp_age", "age")
```

## Combine household and non-household data
```{r}
setnames(dt_household, "hh_met_this_day", "y")
dt_household$type <- "hh"

dt_non_household$y <- 1
dt_non_household$type <- "nhh"

# Combine household and non-household contacts
dt.cmb <- rbind(dt_non_household[,.(new_id, wave, type, alter_age_strata, alter_gender, y)], 
                dt_household[,.(new_id, wave, type, alter_age_strata, alter_gender, y)])

dt.cmb$type <- factor(dt.cmb$type, levels=c("hh", "nhh"))
dt.cmb <- dt.cmb[order(wave, new_id),]

# Merge with participant data
dt.cmb <- merge(dt.cmb, dt_participants, by=c("new_id", "wave"), all.x = TRUE)

# Sanity check
sum(dt.cmb$y, na.rm = T) + sum(dt.amb$y_amb) + sum(dt.grp$y)
```

## Aggregate contacts
```{r}
# Participant size by wave and repetition
dt_participants.size <- dt_participants[, .(N = .N), by=.(u, wave, rep, imp_age, gender)]
setnames(dt_participants.size, "imp_age", "age")

# Aggregate age-gender-specific contacts
dt.cmb.agg <- dt.cmb[, .(y = sum(y, na.rm=T)), by=.(u, wave, rep, imp_age, gender, alter_age_strata, alter_gender)]
setnames(dt.cmb.agg, "imp_age", "age")

# Aggregate ambiguous contacts
dt.amb.agg <- dt.amb[, .(y_amb = sum(y_amb, na.rm=T)), by=.(wave, imp_age, gender)]
setnames(dt.amb.agg, c("imp_age", "y_amb"), c("age", "y"))

# Total number of contacts (specific + ambiguous + group)
dt.cmb.agg.margin <- dt.cmb.agg[,.(y = sum(y, na.rm=T)), by=.(wave, age, gender)]
dt.tot <- rbind(dt.cmb.agg.margin, dt.amb.agg, dt.grp)
dt.tot <- dt.tot[,.(y = sum(y, na.rm=T)), by=.(wave, age, gender)]
setnames(dt.tot, "y", "y_tot")

# Calculate S term
dt.amb.agg.margin <- merge(dt.cmb.agg.margin, dt.tot, by=c("wave", "age","gender"), all.x=TRUE)
dt.amb.agg.margin[, S := y/y_tot]
dt.amb.agg.margin[, S := ifelse(is.nan(S), 1, S)]

# Offset terms
dt.offsets <- merge(dt_participants.size, dt.amb.agg.margin[,.(wave, age, gender, S)], 
                    by=c("wave","age","gender"), all.x = T)
dt.offsets[is.na(S), S := 1]

dt.tot[, .(y = sum(y_tot)), by=.(wave)]
```

```{r}
# Remove participants and contacts 85+
dt.cmb.agg <- dt.cmb.agg[!(age > 84 | alter_age_strata == "85+")]
dt.offsets <- dt.offsets[!(age > 84)]

# Remove remaining NAs
dt.cmb.agg <- dt.cmb.agg[!is.na(alter_gender)]
```

```{r}
g <- age_gender_grid(85, 15, gender = TRUE)
d <- merge(g, dt.cmb.agg, 
           by = c("u", "age", "gender", "alter_age_strata", "alter_gender"), 
           all.x = TRUE)
d <- merge(d, dt.offsets[, .(u, age, gender, N, S)], 
           by = c("u", "age", "gender"), 
           all.x = TRUE)

# Impute true zeroes
d <- d[!is.na(N)]
d <- d[is.na(y), y := 0]

# Recover wave and rep
d[, wave := fcase(u == 1, 1, 
                  u <= 3, 2,
                  u <= 6, 3,
                  u <= 10, 4,
                  u <= 15, 5)]

d[, rep := fcase(wave == 1, 0, 
                 wave == 2, u - wave,
                 wave >= 3, u - 1/2*(wave-1)*(wave)-1)]
```

## Data check
```{r}
tmp <- d[, m := y/N]
ggplot(tmp[u == 1], aes(age, alter_age_strata)) + 
  geom_tile(aes(fill = m)) + 

  facet_grid(gender ~ alter_gender) + 
  viridis::scale_fill_viridis(option='H') +
  theme_bw() + 
  theme(aspect.ratio = 1)
```

## Export data
```{r}
covimod_processed <- list(
  u.missing = u.missing,
  contacts = d,
  offsets = dt.offsets,
  pop = covimod$pop
)

data_name <- paste("COVIMOD_multi", SEED, sep = "_")
saveRDS(covimod_processed, 
        file = file.path("../data",
                         "COVIMOD",
                         paste0(data_name, ".rds")))
```


